"use strict";
/**
 * Copyright (c) 2020, 2021 Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericRetrier = void 0;
const waiter_1 = require("./waiter");
const helper_1 = require("./helper");
const __1 = require("..");
class DefaultRetryCondition {
    static shouldBeRetried(error) {
        return (error.statusCode >= 500 ||
            (DefaultRetryCondition.RETRYABLE_SERVICE_ERRORS.has(error.statusCode) &&
                DefaultRetryCondition.RETRYABLE_SERVICE_ERRORS.get(error.statusCode) === error.serviceCode));
    }
}
/**
 * Default retry condition for Retry mechanism
 * NOTE : Retries are not supported for requests that have binary or stream bodies
 */
DefaultRetryCondition.RETRYABLE_SERVICE_ERRORS = new Map([
    [401, "NotAuthenticated"],
    [404, "NotAuthorizedOrNotFound"],
    [409, "IncorrectState"],
    [409, "NotAuthorizedOrResourceAlreadyExists"],
    [429, "TooManyRequests"],
    [500, "InternalServerError"],
    [401, "NotAuthenticated"],
    [404, "NotAuthorizedOrNotFound"],
    [409, "IncorrectState"],
    [409, "NotAuthorizedOrResourceAlreadyExists"],
    [429, "TooManyRequests"],
    [500, "InternalServerError"]
]);
const NoRetryConfigurationDetails = {
    terminationStrategy: new waiter_1.MaxAttemptsTerminationStrategy(1),
    delayStrategy: new waiter_1.ExponentialBackoffDelayStrategy(30),
    retryCondition: DefaultRetryCondition.shouldBeRetried
};
class GenericRetrier {
    constructor(retryConfiguration) {
        this._logger = undefined;
        const preferredRetryConfig = Object.assign(Object.assign({}, NoRetryConfigurationDetails), retryConfiguration);
        this.retryConfiguration = preferredRetryConfig;
    }
    set logger(logger) {
        this._logger = logger;
    }
    static createPreferredRetrier(clientRetryConfiguration, requestRetryConfiguration) {
        let retryConfigToUse = [requestRetryConfiguration, clientRetryConfiguration, {}].filter(configuration => configuration !== null && configuration !== undefined)[0];
        retryConfigToUse = Object.assign(Object.assign({}, NoRetryConfigurationDetails), retryConfigToUse);
        return new GenericRetrier(retryConfigToUse);
    }
    makeServiceCall(httpClient, request, excludeBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const waitContext = new waiter_1.WaitContextImpl();
            let lastKnownError;
            let shouldBeRetried = true;
            while (true) {
                try {
                    const response = yield httpClient.send(request, excludeBody);
                    if (response.status && response.status >= 200 && response.status <= 299) {
                        return response;
                    }
                    else {
                        const errBody = yield helper_1.handleErrorBody(response);
                        const errorObject = helper_1.handleErrorResponse(response, errBody);
                        shouldBeRetried = this.retryConfiguration.retryCondition(errorObject);
                        lastKnownError = errorObject;
                    }
                }
                catch (err) {
                    lastKnownError = new __1.OciError(err.code, "unknown code", err.message, "unknown");
                    shouldBeRetried = true;
                }
                if (!shouldBeRetried ||
                    this.retryConfiguration.terminationStrategy.shouldTerminate(waitContext) ||
                    !GenericRetrier.isRequestRetryable(request)) {
                    if (this._logger)
                        this._logger.debug("Not retrying the service call...");
                    throw lastKnownError;
                }
                yield waiter_1.delay(this.retryConfiguration.delayStrategy.delay(waitContext));
                waitContext.attemptCount++;
                GenericRetrier.refreshRequest(request);
                if (this._logger)
                    this._logger.debug("Retrying the service call, attempt : ", waitContext.attemptCount);
            }
        });
    }
    static refreshRequest(request) {
        request.headers.set("x-date", new Date().toUTCString());
        // TO-DO : Implement resetting/recreating stream/blobs
    }
    static isRequestRetryable(request) {
        if (!request.body)
            return true;
        if (request.body) {
            if (GenericRetrier.isReadableStream(request.body)) {
                return false;
            }
            return true;
        }
    }
    static isReadableStream(obj) {
        return typeof obj._read === "function" && typeof obj._readableState === "object";
    }
}
exports.GenericRetrier = GenericRetrier;
//# sourceMappingURL=retrier.js.map