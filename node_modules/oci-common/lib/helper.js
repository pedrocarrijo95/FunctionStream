"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStringFromRequestBody = exports.formatDateToRFC3339 = exports.addAdditionalHeaders = exports.getSignerAndReqBody = exports.readStringFromReadable = exports.getStringFromResponseBody = exports.convertStringToType = exports.handleErrorBody = exports.handleErrorResponse = exports.mapContainer = void 0;
/**
 * Copyright (c) 2020, 2021 Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */
const fs_1 = require("fs");
const error_1 = require("./error");
const range_1 = require("./range");
const stream_1 = require("stream");
const headers_1 = require("./headers");
const retry_token_header_1 = require("./retry-token-header");
const utils_1 = require("./utils");
function mapContainer(obj, getJsonObj) {
    const constructedObj = {};
    for (let key in obj) {
        constructedObj[key] = getJsonObj(obj[key]);
    }
    return constructedObj;
}
exports.mapContainer = mapContainer;
function handleErrorResponse(response, body) {
    const statusCode = response.status || -1;
    const requestId = response.headers.get("opc-request-id");
    if (body && body.code && body.message) {
        return new error_1.OciError(statusCode, body.code, body.message, requestId);
    }
    else if (typeof body == "string" && body.length > 0) {
        return new error_1.OciError(statusCode, "unknown code", body, requestId);
    }
    else {
        return new error_1.OciError(statusCode, "unknown code", "unknown reason.", requestId);
    }
}
exports.handleErrorResponse = handleErrorResponse;
function handleErrorBody(response) {
    return __awaiter(this, void 0, void 0, function* () {
        let data = yield response.text();
        //  Try to parse string as an object
        try {
            data = JSON.parse(data);
        }
        catch (err) {
            console.log("Cannot parse data into JSON");
        }
        return data;
    });
}
exports.handleErrorBody = handleErrorBody;
function convertStringToType(str, expectedType) {
    if (str == null)
        return str;
    expectedType = expectedType.toLowerCase();
    switch (expectedType) {
        case "string":
            return str;
        case "number":
            return Number(str);
        case "date":
            return formatDateToRFC3339(new Date(str));
        case "common.Range":
            return range_1.Range.parse(str);
    }
}
exports.convertStringToType = convertStringToType;
// get string content from response body
function getStringFromResponseBody(body) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof body === "string") {
            return body;
        }
        if (body instanceof stream_1.Readable) {
            // body is a stream type
            return readStringFromReadable(body);
        }
        // else if (body instanceof Blob) {
        //   // body is a blob type
        //   return readStringFromBlob(body);
        // } else if (body instanceof ReadableStream) {
        //   // body is a fetch readableStream type
        //   return readStringFromFetchReadableStream(body);
        // }
        else {
            // unknown type, unable to read body content for signing, reject it
            throw new Error("Unable to read body content to sign the request");
        }
    });
}
exports.getStringFromResponseBody = getStringFromResponseBody;
// read string from Readable asynchronously, return a string content of it
function readStringFromReadable(readable) {
    return __awaiter(this, void 0, void 0, function* () {
        let contentBuffer = [];
        // set the encoding to return string instead of Buffer
        readable.setEncoding("utf8");
        return new Promise((resolve, reject) => {
            readable.on("end", () => {
                resolve(contentBuffer.join(""));
            });
            readable.on("data", chunk => {
                contentBuffer.push(chunk);
            });
            readable.on("error", err => {
                // if error happened, it will be catched at http signer global error handling
                reject(err);
            });
        });
    });
}
exports.readStringFromReadable = readStringFromReadable;
// read string from fetch ReadbaleString asynchronously, return a string content of it
// export async function readStringFromFetchReadableStream(readable: ReadableStream): Promise<string> {
//   let contentBuffer: Array<string> = [];
//   const reader = readable.getReader();
//   const decoder = new TextDecoder("utf-8");
//   return new Promise<string>((resolve, reject) => {
//     reader
//       .read()
//       .then(function processText({ done, value }): any {
//         if (done) {
//           // reading stream done, resolve it
//           resolve(contentBuffer.join(""));
//         }
//         // put each chunk into a buffer
//         contentBuffer.push(decoder.decode(value));
//         // read more data and call processText function again to read more
//         return reader.read().then(processText);
//       })
//       .catch(function(e) {
//         // reject if has error
//         reject(e);
//       });
//   });
// }
// read string from Blob asynchronously, return a string content of it
// export async function readStringFromBlob(blob: Blob): Promise<string> {
//   const reader = new FileReader();
//   return new Promise<string>((resolve, reject) => {
//     reader.onerror = err => {
//       reader.abort();
//       reject(err);
//     };
//     reader.onload = () => {
//       // read as Text is called, so this will be a string
//       resolve(reader.result as string);
//     };
//     // utf-8 default encoding is used here
//     reader.readAsText(blob);
//   });
// }
// returns duplicated body for separate consumption by signer and Fetch Request
function getSignerAndReqBody(body, forceExcludeBody) {
    const singerAndReqBody = { signerBody: undefined, requestBody: undefined };
    // If body does not exist or empty body
    if (!body || utils_1.isEmpty(body)) {
        return singerAndReqBody;
    }
    // If body is excluded for signing, no need to send signer body
    if (forceExcludeBody) {
        singerAndReqBody.requestBody = body;
        return singerAndReqBody;
    }
    // if body of type string, can be duplicated.
    if (typeof body === "string") {
        return { signerBody: body, requestBody: body };
    }
    // If body instance of Readable , duplicate the stream for signer and request body
    else if (body instanceof stream_1.Readable) {
        const signerbody = body.pipe(new stream_1.PassThrough());
        const reqBody = body.pipe(new stream_1.PassThrough());
        return { signerBody: signerbody, requestBody: reqBody };
    }
    // //if body instance of blob, can be duplicated.
    // else if (body instanceof Blob) {
    //   return { signerBody: body, requestBody: body };
    // }
    // // if body instance of ReadableStream, tee() it.
    // else if (body instanceof ReadableStream) {
    //   // body.tee() not supported in IE.
    //   // https://jira.oci.oraclecorp.com/browse/DEX-7126
    //   const duplicateStream = body.tee();
    //   return { signerBody: duplicateStream[0], requestBody: duplicateStream[1] };
    // }
    // unknown type, unable to read body content.
    else
        throw new Error("Unable to read body content");
}
exports.getSignerAndReqBody = getSignerAndReqBody;
function addAdditionalHeaders(headers, params) {
    headers_1.addOpcRequestId(headers);
    headers_1.addUserAgent(headers);
    retry_token_header_1.addRetryToken(headers);
    autoDetectContentLength(headers, params);
}
exports.addAdditionalHeaders = addAdditionalHeaders;
function autoDetectContentLength(headers, params) {
    // Auto Detect content-length if needed
    const reqHeaders = params.headerParams;
    if (reqHeaders) {
        if ("content-length" in reqHeaders && reqHeaders["content-length"] === undefined) {
            headers.append("content-length", String(calculateContentLength(params.bodyContent)));
        }
        else if ("Content-Length" in reqHeaders && reqHeaders["Content-Length"] === undefined) {
            headers.append("content-length", String(calculateContentLength(params.bodyContent)));
        }
    }
}
// Helper method to auto detect content-length if not given.
function calculateContentLength(body) {
    let start = 0;
    let end = 0;
    const bodyType = typeof body;
    // If bodyType is a Readable object
    if (bodyType == "object") {
        const path = body.path;
        start = body.start || 0;
        if (body.end === Infinity) {
            end = fs_1.statSync(path).size;
        }
        else if (!isNaN(body.end)) {
            end = body.end + 1;
        }
        else {
            // Have the user calculate the request body content-length if SDK is unable to auto-calculate contentLength.
            throw Error("SDK could not calculate contentLength from the request stream, please add contentLength and try again.");
        }
        return end - start;
    }
    // bodyType must be a string.
    return body.length;
}
// Helper method to format Date Objects to RFC3339 timestamp string.
function formatDateToRFC3339(date) {
    return (date.getFullYear() +
        "-" +
        ("0" + (date.getMonth() + 1)).slice(-2) +
        "-" +
        ("0" + date.getDate()).slice(-2) +
        "T" +
        date.getHours() +
        ":" +
        ("0" + date.getMinutes()).slice(-2) +
        ":" +
        ("0" + date.getSeconds()).slice(-2) +
        "Z");
}
exports.formatDateToRFC3339 = formatDateToRFC3339;
// get string content from body
function getStringFromRequestBody(body) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof body === "string") {
            return body;
        }
        if (body instanceof stream_1.Readable) {
            // body is a stream type
            return readStringFromReadable(body);
        }
        // else if (body instanceof Blob) {
        //   // body is a blob type
        //   return readStringFromBlob(body);
        // } else if (body instanceof ReadableStream) {
        //   // body is a fetch readableStream type
        //   return readStringFromFetchReadableStream(body);
        // }
        else {
            // unknown type, unable to read body content for signing, reject it
            throw new Error("Unable to read body content to sign the request");
        }
    });
}
exports.getStringFromRequestBody = getStringFromRequestBody;
//# sourceMappingURL=helper.js.map